{"version":3,"file":"jointBilateralFilterStage.js","sourceRoot":"","sources":["../../../../lib/processors/webgl2/pipelines/jointBilateralFilterStage.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  inputResolutions,\n  SegmentationConfig,\n} from '../helpers/segmentationHelper'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport function buildJointBilateralFilterStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  inputTexture: WebGLTexture,\n  segmentationConfig: SegmentationConfig,\n  outputTexture: WebGLTexture,\n  canvas: HTMLCanvasElement\n) {\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_segmentationMask;\n    uniform vec2 u_texelSize;\n    uniform float u_step;\n    uniform float u_radius;\n    uniform float u_offset;\n    uniform float u_sigmaTexel;\n    uniform float u_sigmaColor;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    float gaussian(float x, float sigma) {\n      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);\n      return exp((x * x) * coeff);\n    }\n\n    void main() {\n      vec2 centerCoord = v_texCoord;\n      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;\n      float newVal = 0.0;\n\n      float spaceWeight = 0.0;\n      float colorWeight = 0.0;\n      float totalWeight = 0.0;\n\n      vec2 leftTopCoord = vec2(centerCoord + vec2(-u_radius, -u_radius) * u_texelSize);\n      vec2 rightTopCoord = vec2(centerCoord + vec2(u_radius, -u_radius) * u_texelSize);\n      vec2 leftBottomCoord = vec2(centerCoord + vec2(-u_radius, u_radius) * u_texelSize);\n      vec2 rightBottomCoord = vec2(centerCoord + vec2(u_radius, u_radius) * u_texelSize);\n\n      float leftTopSegAlpha = texture(u_segmentationMask, leftTopCoord).a;\n      float rightTopSegAlpha = texture(u_segmentationMask, rightTopCoord).a;\n      float leftBottomSegAlpha = texture(u_segmentationMask, leftBottomCoord).a;\n      float rightBottomSegAlpha = texture(u_segmentationMask, rightBottomCoord).a;\n      float totalSegAlpha = leftTopSegAlpha + rightTopSegAlpha + leftBottomSegAlpha + rightBottomSegAlpha;\n\n      if (totalSegAlpha <= 0.0) {\n        outColor = vec4(vec3(0.0), 0.0);\n      } else if (totalSegAlpha >= 4.0) {\n        outColor = vec4(vec3(0.0), 1.0);\n      } else {\n        for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {\n          for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {\n            vec2 shift = vec2(j, i) * u_texelSize;\n            vec2 coord = vec2(centerCoord + shift);\n            vec3 frameColor = texture(u_inputFrame, coord).rgb;\n            float outVal = texture(u_segmentationMask, coord).a;\n\n            spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);\n            colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);\n            totalWeight += spaceWeight * colorWeight;\n\n            newVal += spaceWeight * colorWeight * outVal;\n          }\n        }\n        newVal /= totalWeight;\n\n        outColor = vec4(vec3(0.0), newVal);\n      }\n    }\n  `\n\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n  const { width: outputWidth, height: outputHeight } = canvas\n  const texelWidth = 1 / outputWidth\n  const texelHeight = 1 / outputHeight\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const segmentationMaskLocation = gl.getUniformLocation(\n    program,\n    'u_segmentationMask'\n  )\n  const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize')\n  const stepLocation = gl.getUniformLocation(program, 'u_step')\n  const radiusLocation = gl.getUniformLocation(program, 'u_radius')\n  const offsetLocation = gl.getUniformLocation(program, 'u_offset')\n  const sigmaTexelLocation = gl.getUniformLocation(program, 'u_sigmaTexel')\n  const sigmaColorLocation = gl.getUniformLocation(program, 'u_sigmaColor')\n\n  const frameBuffer = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    outputTexture,\n    0\n  )\n\n  gl.useProgram(program)\n  gl.uniform1i(inputFrameLocation, 0)\n  gl.uniform1i(segmentationMaskLocation, 1)\n  gl.uniform2f(texelSizeLocation, texelWidth, texelHeight)\n\n  // Ensures default values are configured to prevent infinite\n  // loop in fragment shader\n  updateSigmaSpace(0)\n  updateSigmaColor(0)\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, inputTexture)\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function updateSigmaSpace(sigmaSpace: number) {\n    sigmaSpace *= Math.max(\n      outputWidth / segmentationWidth,\n      outputHeight / segmentationHeight\n    )\n\n    const kSparsityFactor = 0.66 // Higher is more sparse.\n    const sparsity = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor)\n    const step = sparsity\n    const radius = sigmaSpace\n    const offset = step > 1 ? step * 0.5 : 0\n    const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace\n\n    gl.useProgram(program)\n    gl.uniform1f(stepLocation, step)\n    gl.uniform1f(radiusLocation, radius)\n    gl.uniform1f(offsetLocation, offset)\n    gl.uniform1f(sigmaTexelLocation, sigmaTexel)\n  }\n\n  function updateSigmaColor(sigmaColor: number) {\n    gl.useProgram(program)\n    gl.uniform1f(sigmaColorLocation, sigmaColor)\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return { render, updateSigmaSpace, updateSigmaColor, cleanUp }\n}\n"]}