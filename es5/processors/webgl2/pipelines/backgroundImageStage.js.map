{"version":3,"file":"backgroundImageStage.js","sourceRoot":"","sources":["../../../../lib/processors/webgl2/pipelines/backgroundImageStage.ts"],"names":[],"mappings":"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","sourcesContent":["import { BlendMode } from '../helpers/postProcessingHelper'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  createTexture,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport type BackgroundImageStage = {\n  render(): void\n  updateCoverage(coverage: [number, number]): void\n  updateLightWrapping(lightWrapping: number): void\n  updateBlendMode(blendMode: BlendMode): void\n  cleanUp(): void\n}\n\nexport function buildBackgroundImageStage(\n  gl: WebGL2RenderingContext,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  personMaskTexture: WebGLTexture,\n  backgroundImage: HTMLImageElement | null,\n  canvas: HTMLCanvasElement\n): BackgroundImageStage {\n  const vertexShaderSource = glsl`#version 300 es\n\n    uniform vec2 u_backgroundScale;\n    uniform vec2 u_backgroundOffset;\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n    out vec2 v_backgroundCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;\n    }\n  `\n\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_background;\n    uniform vec2 u_coverage;\n    uniform float u_lightWrapping;\n    uniform float u_blendMode;\n\n    in vec2 v_texCoord;\n    in vec2 v_backgroundCoord;\n\n    out vec4 outColor;\n\n    vec3 screen(vec3 a, vec3 b) {\n      return 1.0 - (1.0 - a) * (1.0 - b);\n    }\n\n    vec3 linearDodge(vec3 a, vec3 b) {\n      return a + b;\n    }\n\n    void main() {\n      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);\n      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;\n      frameColor = u_blendMode * linearDodge(frameColor, lightWrap) +\n        (1.0 - u_blendMode) * screen(frameColor, lightWrap);\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);\n    }\n  `\n\n  const { width: outputWidth, height: outputHeight } = canvas\n  const outputRatio = outputWidth / outputHeight\n\n  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource)\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const backgroundScaleLocation = gl.getUniformLocation(\n    program,\n    'u_backgroundScale'\n  )\n  const backgroundOffsetLocation = gl.getUniformLocation(\n    program,\n    'u_backgroundOffset'\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const personMaskLocation = gl.getUniformLocation(program, 'u_personMask')\n  const backgroundLocation = gl.getUniformLocation(program, 'u_background')\n  const coverageLocation = gl.getUniformLocation(program, 'u_coverage')\n  const lightWrappingLocation = gl.getUniformLocation(\n    program,\n    'u_lightWrapping'\n  )\n  const blendModeLocation = gl.getUniformLocation(program, 'u_blendMode')\n\n  gl.useProgram(program)\n  gl.uniform2f(backgroundScaleLocation, 1, 1)\n  gl.uniform2f(backgroundOffsetLocation, 0, 0)\n  gl.uniform1i(inputFrameLocation, 0)\n  gl.uniform1i(personMaskLocation, 1)\n  gl.uniform2f(coverageLocation, 0, 1)\n  gl.uniform1f(lightWrappingLocation, 0)\n  gl.uniform1f(blendModeLocation, 0)\n\n  let backgroundTexture: WebGLTexture | null = null\n  // TODO Find a better to handle background being loaded\n  if (backgroundImage?.complete) {\n    updateBackgroundImage(backgroundImage)\n  } else if (backgroundImage) {\n    backgroundImage.onload = () => {\n      updateBackgroundImage(backgroundImage)\n    }\n  }\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture)\n    if (backgroundTexture !== null) {\n      gl.activeTexture(gl.TEXTURE2)\n      gl.bindTexture(gl.TEXTURE_2D, backgroundTexture)\n      // TODO Handle correctly the background not loaded yet\n      gl.uniform1i(backgroundLocation, 2)\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function updateBackgroundImage(backgroundImage: HTMLImageElement) {\n    backgroundTexture = createTexture(\n      gl,\n      gl.RGBA8,\n      backgroundImage.naturalWidth,\n      backgroundImage.naturalHeight,\n      gl.LINEAR,\n      gl.LINEAR\n    )\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      0,\n      0,\n      backgroundImage.naturalWidth,\n      backgroundImage.naturalHeight,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      backgroundImage\n    )\n\n    let xOffset = 0\n    let yOffset = 0\n    let backgroundWidth = backgroundImage.naturalWidth\n    let backgroundHeight = backgroundImage.naturalHeight\n    const backgroundRatio = backgroundWidth / backgroundHeight\n    if (backgroundRatio < outputRatio) {\n      backgroundHeight = backgroundWidth / outputRatio\n      yOffset = (backgroundImage.naturalHeight - backgroundHeight) / 2\n    } else {\n      backgroundWidth = backgroundHeight * outputRatio\n      xOffset = (backgroundImage.naturalWidth - backgroundWidth) / 2\n    }\n\n    const xScale = backgroundWidth / backgroundImage.naturalWidth\n    const yScale = backgroundHeight / backgroundImage.naturalHeight\n    xOffset /= backgroundImage.naturalWidth\n    yOffset /= backgroundImage.naturalHeight\n\n    gl.uniform2f(backgroundScaleLocation, xScale, yScale)\n    gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset)\n  }\n\n  function updateCoverage(coverage: [number, number]) {\n    gl.useProgram(program)\n    gl.uniform2f(coverageLocation, coverage[0], coverage[1])\n  }\n\n  function updateLightWrapping(lightWrapping: number) {\n    gl.useProgram(program)\n    gl.uniform1f(lightWrappingLocation, lightWrapping)\n  }\n\n  function updateBlendMode(blendMode: BlendMode) {\n    gl.useProgram(program)\n    gl.uniform1f(blendModeLocation, blendMode === 'screen' ? 0 : 1)\n  }\n\n  function cleanUp() {\n    gl.deleteTexture(backgroundTexture)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n    gl.deleteShader(vertexShader)\n  }\n\n  return {\n    render,\n    updateCoverage,\n    updateLightWrapping,\n    updateBlendMode,\n    cleanUp,\n  }\n}\n"]}