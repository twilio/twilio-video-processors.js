{"version":3,"file":"VirtualBackgroundProcessor.js","sourceRoot":"","sources":["../../../lib/processors/background/VirtualBackgroundProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["import { BackgroundProcessor, BackgroundProcessorOptions } from './BackgroundProcessor';\nimport { ImageFit, WebGL2PipelineType } from '../../types';\n\n/**\n * Options passed to [[VirtualBackgroundProcessor]] constructor.\n */\nexport interface VirtualBackgroundProcessorOptions extends BackgroundProcessorOptions {\n  /**\n   * The HTMLImageElement to use for background replacement.\n   * An error will be raised if the image hasn't been fully loaded yet. Additionally, the image must follow\n   * [security guidelines](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)\n   * when loading the image from a different origin. Failing to do so will result to an empty output frame.\n   */\n  backgroundImage: HTMLImageElement;\n\n  /**\n   * The [[ImageFit]] to use for positioning of the background image in the viewport. Only the Canvas2D [[Pipeline]]\n   * supports this option. WebGL2 ignores this option and falls back to Cover.\n   * @default\n   * ```html\n   * 'Fill'\n   * ```\n   */\n  fitType?: ImageFit;\n}\n\n/**\n * The VirtualBackgroundProcessor, when added to a VideoTrack,\n * replaces the background in each video frame with a given image,\n * and leaves the foreground (person(s)) untouched. Each instance of\n * VirtualBackgroundProcessor should be added to only one VideoTrack\n * at a time to prevent overlapping of image data from multiple VideoTracks.\n *\n * @example\n *\n * ```ts\n * import { createLocalVideoTrack } from 'twilio-video';\n * import { Pipeline, VirtualBackgroundProcessor } from '@twilio/video-processors';\n *\n * let virtualBackground;\n * const img = new Image();\n *\n * img.onload = () => {\n *   virtualBackground = new VirtualBackgroundProcessor({\n *     assetsPath: 'https://my-server-path/assets',\n *     backgroundImage: img,\n *     pipeline: Pipeline.WebGL2,\n *\n *     // Desktop Safari and iOS browsers do not support SIMD.\n *     // Set debounce to true to achieve an acceptable performance.\n *     debounce: isSafari(),\n *   });\n *\n *   virtualBackground.loadModel().then(() => {\n *     createLocalVideoTrack({\n *       // Increasing the capture resolution decreases the output FPS\n *       // especially on browsers that do not support SIMD\n *       // such as desktop Safari and iOS browsers, or on Chrome\n *       // with capture resolutions above 640x480 for webgl2.\n *       width: 640,\n *       height: 480,\n *       // Any frame rate above 24 fps on desktop browsers increase CPU\n *       // usage without noticeable increase in quality.\n *       frameRate: 24\n *     }).then(track => {\n *       track.addProcessor(virtualBackground, {\n *         inputFrameBufferType: 'video',\n *         outputFrameBufferContextType: 'webgl2',\n *       });\n *     });\n *   });\n * };\n * img.src = '/background.jpg';\n * ```\n */\nexport class VirtualBackgroundProcessor extends BackgroundProcessor {\n\n  private _fitType!: ImageFit;\n  // tslint:disable-next-line no-unused-variable\n  private readonly _name: string = 'VirtualBackgroundProcessor';\n\n  /**\n   * Construct a VirtualBackgroundProcessor. Default values will be used for\n   * any missing optional properties in [[VirtualBackgroundProcessorOptions]],\n   * and invalid properties will be ignored.\n   */\n  constructor(options: VirtualBackgroundProcessorOptions) {\n    super(options);\n    this.backgroundImage = options.backgroundImage;\n    this.fitType = options.fitType!;\n  }\n\n  /**\n   * The HTMLImageElement representing the current background image.\n   */\n  get backgroundImage(): HTMLImageElement {\n    return this._backgroundImage!;\n  }\n\n  /**\n   * Set an HTMLImageElement as the new background image.\n   * An error will be raised if the image hasn't been fully loaded yet. Additionally, the image must follow\n   * [security guidelines](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image)\n   * when loading the image from a different origin. Failing to do so will result to an empty output frame.\n   */\n  set backgroundImage(image: HTMLImageElement) {\n    if (!image || !image.complete || !image.naturalHeight) {\n      throw new Error('Invalid image. Make sure that the image is an HTMLImageElement and has been successfully loaded');\n    }\n    this._backgroundImage = image;\n\n    // Triggers recreation of the pipeline in the next processFrame call\n    this._webgl2Pipeline?.cleanUp();\n    this._webgl2Pipeline = null;\n  }\n\n  /**\n   * The current [[ImageFit]] for positioning of the background image in the viewport.\n   */\n  get fitType(): ImageFit {\n    return this._fitType;\n  }\n\n  /**\n   * Set a new [[ImageFit]] to be used for positioning the background image in the viewport.\n   */\n  set fitType(fitType: ImageFit) {\n    const validTypes = Object.keys(ImageFit);\n    if (!validTypes.includes(fitType as any)) {\n      console.warn(`Valid fitType not found. Using '${ImageFit.Fill}' as default.`);\n      fitType = ImageFit.Fill;\n    }\n    this._fitType = fitType;\n  }\n\n  protected _getWebGL2PipelineType(): WebGL2PipelineType {\n    return WebGL2PipelineType.Image;\n  }\n\n  protected _setBackground(): void {\n    if (!this._outputContext || !this._outputCanvas) {\n      return;\n    }\n    const img = this._backgroundImage!;\n    const imageWidth = img.naturalWidth;\n    const imageHeight = img.naturalHeight;\n    const canvasWidth = this._outputCanvas.width;\n    const canvasHeight = this._outputCanvas.height;\n    const ctx = this._outputContext as CanvasRenderingContext2D;\n\n    if (this._fitType === ImageFit.Fill) {\n      ctx.drawImage(img, 0, 0, imageWidth, imageHeight, 0, 0, canvasWidth, canvasHeight);\n    } else if (this._fitType === ImageFit.None) {\n      ctx.drawImage(img, 0, 0, imageWidth, imageHeight);\n    } else if (this._fitType === ImageFit.Contain) {\n      const { x, y, w, h } = this._getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight, ImageFit.Contain);\n      ctx.drawImage(img, 0, 0, imageWidth, imageHeight, x, y, w, h);\n    } else if (this._fitType === ImageFit.Cover) {\n      const { x, y, w, h } = this._getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight, ImageFit.Cover);\n      ctx.drawImage(img, 0, 0, imageWidth, imageHeight, x, y, w, h);\n    }\n  }\n\n  private _getFitPosition(contentWidth: number, contentHeight: number,\n    viewportWidth: number, viewportHeight: number, type: ImageFit)\n      : { h: number, w: number, x: number, y: number } {\n\n    // Calculate new content width to fit viewport width\n    let factor = viewportWidth / contentWidth;\n    let newContentWidth = viewportWidth;\n    let newContentHeight = factor * contentHeight;\n\n    // Scale down the resulting height and width more\n    // to fit viewport height if the content still exceeds it\n    if ((type === ImageFit.Contain && newContentHeight > viewportHeight)\n      || (type === ImageFit.Cover && viewportHeight > newContentHeight)) {\n      factor = viewportHeight / newContentHeight;\n      newContentWidth = factor * newContentWidth;\n      newContentHeight = viewportHeight;\n    }\n\n    // Calculate the destination top left corner to center the content\n    const x = (viewportWidth - newContentWidth) / 2;\n    const y = (viewportHeight - newContentHeight) / 2;\n\n    return {\n      x, y,\n      w: newContentWidth,\n      h: newContentHeight,\n    };\n  }\n}\n"]}