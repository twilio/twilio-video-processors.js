{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../lib/processors/background/pipelines/personmaskupscalepipeline/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { BilateralFilterConfig, Dimensions, InputFrame } from '../../../../types';\nimport { WebGL2Pipeline } from '../../../pipelines';\nimport { SinglePassBilateralFilterStage } from './SinglePassBilateralFilterStage';\n\n/**\n * @private\n */\nexport class PersonMaskUpscalePipeline extends WebGL2Pipeline {\n  private readonly _outputCanvas: OffscreenCanvas | HTMLCanvasElement;\n  private readonly _inputDimensions: Dimensions;\n  private _isWebGL2Supported: boolean = true;\n  private _maskBlurRadius: number;\n  \n  constructor(\n    inputDimensions: Dimensions,\n    outputCanvas: OffscreenCanvas | HTMLCanvasElement,\n    maskBlurRadius: number\n  ) {\n    super();\n    \n    this._outputCanvas = outputCanvas;\n    this._inputDimensions = inputDimensions;\n    this._maskBlurRadius = maskBlurRadius;\n\n      const glOut = outputCanvas.getContext('webgl2');\n      if (glOut) {\n        this.initializeWebGL2Pipeline(glOut as WebGL2RenderingContext);\n      } else {\n        this._isWebGL2Supported = false;\n        console.warn('Downgraded to Canvas2D for person mask upscaling due to missing WebGL2 support.');\n      }\n  }\n\n  private initializeWebGL2Pipeline(glOut: WebGL2RenderingContext): void {\n    const outputDimensions = {\n      height: this._outputCanvas.height,\n      width: this._outputCanvas.width\n    };\n\n    this.addStage(new WebGL2Pipeline.InputStage(glOut));\n\n    this.addStage(new SinglePassBilateralFilterStage(\n      glOut,\n      'horizontal',\n      'texture',\n      this._inputDimensions,\n      outputDimensions,\n      1,\n      2\n    ));\n\n    this.addStage(new SinglePassBilateralFilterStage(\n      glOut,\n      'vertical',\n      'canvas',\n      this._inputDimensions,\n      outputDimensions,\n      2\n    ));\n  }\n\n  render(\n    inputFrame: InputFrame,\n    personMask: ImageData\n  ): void {\n    if (this._isWebGL2Supported) {\n      // Use WebGL2 pipeline when supported\n      super.render(inputFrame, personMask);\n    } else {\n      // Fallback for browsers without WebGL2 support\n      this._renderFallback(inputFrame, personMask);\n    }\n  }\n  \n  /**\n   * Render the person mask using a Canvas 2D context as a fallback for browsers without WebGL2 support\n   * @param inputFrame - The input frame to render\n   * @param personMask - The person mask to render\n   */\n  private _renderFallback(\n    inputFrame: InputFrame,\n    personMask: ImageData\n  ): void {\n    // Create a temporary canvas for the mask\n    const maskCanvas = new OffscreenCanvas(personMask.width, personMask.height);\n    const maskCtx = maskCanvas.getContext('2d')!;\n    maskCtx.putImageData(personMask, 0, 0);\n\n    // Get 2D context for drawing\n    const ctx = this._outputCanvas.getContext('2d') as CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n    ctx.save();\n    ctx.filter = `blur(${this._maskBlurRadius}px)`;\n    ctx.globalCompositeOperation = 'copy';\n    ctx.drawImage(maskCanvas, 0, 0, this._outputCanvas.width, this._outputCanvas.height);\n    ctx.filter = 'none';\n    ctx.globalCompositeOperation = 'source-in';\n    ctx.drawImage(inputFrame, 0, 0, this._outputCanvas.width, this._outputCanvas.height);\n    ctx.restore();\n  }\n\n  updateBilateralFilterConfig(config: BilateralFilterConfig) {\n    const { sigmaSpace } = config;\n    if (typeof sigmaSpace !== 'number') {\n      return;\n    }\n    if (!this._isWebGL2Supported) {\n      this._maskBlurRadius = sigmaSpace;\n      // SinglePassBilateralFilterStage is not supported in Canvas2D fallback\n      return;\n    }\n    const [\n      /* inputStage */,\n      ...bilateralFilterStages\n    ] = this._stages;\n\n    (bilateralFilterStages as SinglePassBilateralFilterStage[]).forEach(\n      (stage) => {\n        stage.updateSigmaColor(0.1);\n        stage.updateSigmaSpace(sigmaSpace);\n      }\n    );\n  }\n\n  cleanUp(): void {\n    if(this._isWebGL2Supported) {\n      super.cleanUp();\n    }\n  }\n}\n"]}