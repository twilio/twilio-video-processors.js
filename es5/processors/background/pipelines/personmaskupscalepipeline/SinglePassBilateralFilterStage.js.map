{"version":3,"file":"SinglePassBilateralFilterStage.js","sourceRoot":"","sources":["../../../../../lib/processors/background/pipelines/personmaskupscalepipeline/SinglePassBilateralFilterStage.ts"],"names":[],"mappings":"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","sourcesContent":["import { Dimensions } from '../../../../types';\nimport { WebGL2Pipeline } from '../../../pipelines';\n\n/**\n * @private\n */\nfunction createSpaceWeights(\n  radius: number,\n  sigma: number,\n  texelSize: number\n): number[] {\n  return '0'.repeat(radius).split('').map((zero, i) => {\n    const x = (i + 1) * texelSize;\n    return Math.exp(-0.5 * x * x / sigma / sigma);\n  });\n}\n\n/**\n * @private\n */\nfunction createColorWeights(\n  sigma: number\n): number[] {\n  return '0'.repeat(256).split('').map((zero, i) => {\n    const x = i / 255;\n    return Math.exp(-0.5 * x * x / sigma / sigma);\n  });\n}\n\n/**\n * @private\n */\nexport class SinglePassBilateralFilterStage extends WebGL2Pipeline.ProcessingStage {\n  private readonly _direction: 'horizontal' | 'vertical';\n  private readonly _inputDimensions: Dimensions;\n\n  constructor(\n    glOut: WebGL2RenderingContext,\n    direction: 'horizontal' | 'vertical',\n    outputType: 'canvas' | 'texture',\n    inputDimensions: Dimensions,\n    outputDimensions: Dimensions,\n    inputTextureUnit: number,\n    outputTextureUnit = inputTextureUnit + 1\n  ) {\n    const {\n      height,\n      width\n    } = outputDimensions;\n\n    super(\n      {\n        textureName: 'u_segmentationMask',\n        textureUnit: inputTextureUnit\n      },\n      {\n        fragmentShaderSource: `#version 300 es\n          precision highp float;\n\n          uniform sampler2D u_inputFrame;\n          uniform sampler2D u_segmentationMask;\n          uniform vec2 u_texelSize;\n          uniform float u_direction;\n          uniform float u_radius;\n          uniform float u_step;\n          uniform float u_spaceWeights[128];\n          uniform float u_colorWeights[256];\n\n          in vec2 v_texCoord;\n\n          out vec4 outColor;\n\n          float calculateColorWeight(vec2 coord, vec3 centerColor) {\n            vec3 coordColor = texture(u_inputFrame, coord).rgb;\n            float x = distance(centerColor, coordColor);\n            return u_colorWeights[int(x * 255.0)];\n          }\n\n          float edgePixelsAverageAlpha(float outAlpha) {\n            float totalAlpha = outAlpha;\n            float totalPixels = 1.0;\n\n            for (float i = -u_radius; u_radius > 0.0 && i <= u_radius; i += u_radius) {\n              for (float j = -u_radius; j <= u_radius; j += u_radius * (j == 0.0 ? 2.0 : 1.0)) {\n                vec2 shift = vec2(i, j) * u_texelSize;\n                vec2 coord = vec2(v_texCoord + shift);\n                totalAlpha += texture(u_segmentationMask, coord).a;\n                totalPixels++;\n              }\n            }\n\n            return totalAlpha / totalPixels;\n          }\n\n          void main() {\n            vec3 centerColor = texture(u_inputFrame, v_texCoord).rgb;\n            float outAlpha = texture(u_segmentationMask, v_texCoord).a;\n            float averageAlpha = edgePixelsAverageAlpha(outAlpha);\n            float totalWeight = 1.0;\n\n            if (averageAlpha == 0.0 || averageAlpha == 1.0) {\n              outColor = vec4(averageAlpha * centerColor, averageAlpha);\n              return;\n            }\n\n            for (float i = 1.0; i <= u_radius; i += u_step) {\n              float x = (1.0 - u_direction) * i;\n              float y = u_direction * i;\n              vec2 shift = vec2(x, y) * u_texelSize;\n              vec2 coord = vec2(v_texCoord + shift);\n              float spaceWeight = u_spaceWeights[int(i - 1.0)];\n              float colorWeight = calculateColorWeight(coord, centerColor);\n              float weight = spaceWeight * colorWeight;\n              float alpha = texture(u_segmentationMask, coord).a;\n              totalWeight += weight;\n              outAlpha += weight * alpha;\n\n              shift = vec2(-x, -y) * u_texelSize;\n              coord = vec2(v_texCoord + shift);\n              colorWeight = calculateColorWeight(coord, centerColor);\n              weight = spaceWeight * colorWeight;\n              alpha = texture(u_segmentationMask, coord).a;\n              totalWeight += weight;\n              outAlpha += weight * alpha;\n            }\n\n            outAlpha /= totalWeight;\n            outColor = vec4(outAlpha * centerColor, outAlpha);\n          }\n        `,\n        glOut,\n        height,\n        textureUnit: outputTextureUnit,\n        type: outputType,\n        width,\n        uniformVars: [\n          {\n            name: 'u_inputFrame',\n            type: 'int',\n            values: [0]\n          },\n          {\n            name: 'u_direction',\n            type: 'float',\n            values: [direction === 'vertical' ? 1 : 0]\n          },\n          {\n            name: 'u_texelSize',\n            type: 'float',\n            values: [1 / width, 1 / height]\n          }\n        ]\n      }\n    );\n\n    this._direction = direction;\n    this._inputDimensions = inputDimensions;\n    this.updateSigmaColor(0);\n    this.updateSigmaSpace(0);\n  }\n\n  updateSigmaColor(sigmaColor: number): void {\n    this._setUniformVars([\n      {\n        name: 'u_colorWeights',\n        type: 'float:v',\n        values: createColorWeights(\n          sigmaColor\n        )\n      }\n    ]);\n  }\n\n  updateSigmaSpace(sigmaSpace: number): void {\n    const {\n      height: inputHeight,\n      width: inputWidth\n    } = this._inputDimensions;\n\n    const {\n      height: outputHeight,\n      width: outputWidth\n    } = this._outputDimensions;\n\n    sigmaSpace *= Math.max(\n      outputWidth / inputWidth,\n      outputHeight / inputHeight\n    );\n\n    const step = Math.floor(\n      0.5 * sigmaSpace / Math.log(sigmaSpace)\n    );\n\n    const sigmaTexel = Math.max(\n      1 / outputWidth,\n      1 / outputHeight\n    ) * sigmaSpace;\n\n    const texelSize = 1 / (\n      this._direction === 'horizontal'\n        ? outputWidth\n        : outputHeight\n    );\n\n    this._setUniformVars([\n      {\n        name: 'u_radius',\n        type: 'float',\n        values: [sigmaSpace]\n      },\n      {\n        name: 'u_spaceWeights',\n        type: 'float:v',\n        values: createSpaceWeights(\n          sigmaSpace,\n          sigmaTexel,\n          texelSize\n        )\n      },\n      {\n        name: 'u_step',\n        type: 'float',\n        values: [step]\n      }\n    ]);\n  }\n}\n"]}