{"version":3,"file":"VirtualBackgroundProcessorPipeline.js","sourceRoot":"","sources":["../../../../../lib/processors/background/pipelines/backgroundprocessorpipeline/VirtualBackgroundProcessorPipeline.ts"],"names":[],"mappings":"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","sourcesContent":["import { ImageFit } from '../../../../types';\nimport { BackgroundProcessorPipeline, BackgroundProcessorPipelineOptions } from './BackgroundProcessorPipeline';\n\n/**\n * @private\n */\nexport interface VirtualBackgroundProcessorPipelineOptions extends BackgroundProcessorPipelineOptions {\n  fitType: ImageFit;\n}\n\n/**\n * @private\n */\nexport class VirtualBackgroundProcessorPipeline extends BackgroundProcessorPipeline {\n  private _backgroundImage: ImageBitmap | null;\n  private _fitType: ImageFit;\n\n  constructor(options: VirtualBackgroundProcessorPipelineOptions) {\n    super(options);\n\n    const {\n      fitType\n    } = options;\n\n    this._backgroundImage = null;\n    this._fitType = fitType;\n  }\n\n  async setBackgroundImage(\n    backgroundImage: ImageBitmap\n  ): Promise<void> {\n    this._backgroundImage?.close();\n    this._backgroundImage = backgroundImage;\n  }\n\n  async setFitType(fitType: ImageFit): Promise<void> {\n    this._fitType = fitType;\n  }\n\n  protected _setBackground(): void {\n    const {\n      _backgroundImage,\n      _fitType,\n      _outputCanvas\n    } = this;\n\n    if (!_backgroundImage) {\n      return;\n    }\n\n    const ctx = _outputCanvas.getContext('2d')!;\n    const imageWidth = _backgroundImage.width;\n    const imageHeight = _backgroundImage.height;\n    const canvasWidth = _outputCanvas.width;\n    const canvasHeight = _outputCanvas.height;\n\n    if (_fitType === ImageFit.Fill) {\n      ctx.drawImage(\n        _backgroundImage,\n        0,\n        0,\n        imageWidth,\n        imageHeight,\n        0,\n        0,\n        canvasWidth,\n        canvasHeight\n      );\n    } else if (_fitType === ImageFit.None) {\n      ctx.drawImage(\n        _backgroundImage,\n        0,\n        0,\n        imageWidth,\n        imageHeight\n      );\n    } else {\n      const { x, y, w, h } = this._getFitPosition(\n        imageWidth,\n        imageHeight,\n        canvasWidth,\n        canvasHeight,\n        _fitType\n      );\n      ctx.drawImage(\n        _backgroundImage,\n        0,\n        0,\n        imageWidth,\n        imageHeight,\n        x,\n        y,\n        w,\n        h\n      );\n    }\n  }\n\n  private _getFitPosition(\n    contentWidth: number,\n    contentHeight: number,\n    viewportWidth: number,\n    viewportHeight: number,\n    type: ImageFit\n  ): {\n    h: number,\n    w: number,\n    x: number,\n    y: number\n  } {\n\n    // Calculate new content width to fit viewport width\n    let factor = viewportWidth / contentWidth;\n    let newContentWidth = viewportWidth;\n    let newContentHeight = factor * contentHeight;\n\n    // Scale down the resulting height and width more\n    // to fit viewport height if the content still exceeds it\n    if ((type === ImageFit.Contain && newContentHeight > viewportHeight)\n      || (type === ImageFit.Cover && viewportHeight > newContentHeight)) {\n      factor = viewportHeight / newContentHeight;\n      newContentWidth = factor * newContentWidth;\n      newContentHeight = viewportHeight;\n    }\n\n    // Calculate the destination top left corner to center the content\n    const x = (viewportWidth - newContentWidth) / 2;\n    const y = (viewportHeight - newContentHeight) / 2;\n\n    return {\n      x,\n      y,\n      w: newContentWidth,\n      h: newContentHeight,\n    };\n  }\n}\n"]}