{"version":3,"file":"SinglePassGaussianBlurFilterStage.js","sourceRoot":"","sources":["../../../../../lib/processors/background/pipelines/gaussianblurfilterpipeline/SinglePassGaussianBlurFilterStage.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,gDAAoD;AAEpD;;GAEG;AACH,SAAS,yBAAyB,CAAC,MAAc;IAC/C,IAAM,KAAK,GAAG,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;IACtD,OAAO,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,CAAC;QAClD,OAAO,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,MAAM,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;GAEG;AACH;IAAuD,qDAA8B;IACnF,2CACE,KAA6B,EAC7B,SAAoC,EACpC,UAAgC,EAChC,gBAAwB,EACxB,iBAAwC;QAL1C,iBA4EC;QAvEC,kCAAA,EAAA,oBAAoB,gBAAgB,GAAG,CAAC;QAElC,IAAA,KAGF,KAAK,CAAC,MAAM,EAFd,MAAM,YAAA,EACN,KAAK,WACS,CAAC;gBAEjB,kBACE;YACE,WAAW,EAAE,gBAAgB;YAC7B,WAAW,EAAE,gBAAgB;SAC9B,EACD;YACE,oBAAoB,EAAE,kvCAoCrB;YACD,KAAK,OAAA;YACL,MAAM,QAAA;YACN,WAAW,EAAE,iBAAiB;YAC9B,IAAI,EAAE,UAAU;YAChB,KAAK,OAAA;YACL,WAAW,EAAE;gBACX;oBACE,IAAI,EAAE,aAAa;oBACnB,IAAI,EAAE,OAAO;oBACb,MAAM,EAAE,CAAC,SAAS,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC3C;gBACD;oBACE,IAAI,EAAE,aAAa;oBACnB,IAAI,EAAE,OAAO;oBACb,MAAM,EAAE,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,MAAM,CAAC;iBAChC;aACF;SACF,CACF;QAED,KAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;;IACvB,CAAC;IAED,wDAAY,GAAZ,UAAa,MAAc;QACzB,IAAI,CAAC,eAAe,CAAC;YACnB;gBACE,IAAI,EAAE,UAAU;gBAChB,IAAI,EAAE,OAAO;gBACb,MAAM,EAAE,CAAC,MAAM,CAAC;aACjB;YACD;gBACE,IAAI,EAAE,uBAAuB;gBAC7B,IAAI,EAAE,SAAS;gBACf,MAAM,EAAE,yBAAyB,CAAC,MAAM,CAAC;aAC1C;SACF,CAAC,CAAC;IACL,CAAC;IACH,wCAAC;AAAD,CAAC,AA7FD,CAAuD,0BAAc,CAAC,eAAe,GA6FpF;AA7FY,8EAAiC","sourcesContent":["import { WebGL2Pipeline } from '../../../pipelines';\n\n/**\n * @private\n */\nfunction createGaussianBlurWeights(radius: number): number[] {\n  const coeff = 1.0 / Math.sqrt(2.0 * Math.PI) / radius;\n  return '0'.repeat(radius + 1).split('').map((zero, x) => {\n    return coeff * Math.exp(-0.5 * x * x / radius / radius);\n  });\n}\n\n/**\n * @private\n */\nexport class SinglePassGaussianBlurFilterStage extends WebGL2Pipeline.ProcessingStage {\n  constructor(\n    glOut: WebGL2RenderingContext,\n    direction: 'horizontal' | 'vertical',\n    outputType: 'canvas' | 'texture',\n    inputTextureUnit: number,\n    outputTextureUnit = inputTextureUnit + 1\n  ) {\n    const {\n      height,\n      width\n    } = glOut.canvas;\n\n    super(\n      {\n        textureName: 'u_inputTexture',\n        textureUnit: inputTextureUnit\n      },\n      {\n        fragmentShaderSource: `#version 300 es\n          precision highp float;\n\n          uniform sampler2D u_inputTexture;\n          uniform vec2 u_texelSize;\n          uniform float u_direction;\n          uniform float u_radius;\n          uniform float u_gaussianBlurWeights[128];\n\n          in vec2 v_texCoord;\n\n          out vec4 outColor;\n\n          void main() {\n            float totalWeight = u_gaussianBlurWeights[0];\n            vec3 newColor = totalWeight * texture(u_inputTexture, v_texCoord).rgb;\n\n            for (float i = 1.0; i <= u_radius; i += 1.0) {\n              float x = (1.0 - u_direction) * i;\n              float y = u_direction * i;\n\n              vec2 shift = vec2(x, y) * u_texelSize;\n              vec2 coord = vec2(v_texCoord + shift);\n              float weight = u_gaussianBlurWeights[int(i)];\n              newColor += weight * texture(u_inputTexture, coord).rgb;\n              totalWeight += weight;\n\n              shift = vec2(-x, -y) * u_texelSize;\n              coord = vec2(v_texCoord + shift);\n              newColor += weight * texture(u_inputTexture, coord).rgb;\n              totalWeight += weight;\n            }\n\n            newColor /= totalWeight;\n            outColor = vec4(newColor, 1.0);\n          }\n        `,\n        glOut,\n        height,\n        textureUnit: outputTextureUnit,\n        type: outputType,\n        width,\n        uniformVars: [\n          {\n            name: 'u_direction',\n            type: 'float',\n            values: [direction === 'vertical' ? 1 : 0]\n          },\n          {\n            name: 'u_texelSize',\n            type: 'float',\n            values: [1 / width, 1 / height]\n          }\n        ]\n      }\n    );\n\n    this.updateRadius(0);\n  }\n\n  updateRadius(radius: number): void {\n    this._setUniformVars([\n      {\n        name: 'u_radius',\n        type: 'float',\n        values: [radius]\n      },\n      {\n        name: 'u_gaussianBlurWeights',\n        type: 'float:v',\n        values: createGaussianBlurWeights(radius)\n      }\n    ]);\n  }\n}\n"]}