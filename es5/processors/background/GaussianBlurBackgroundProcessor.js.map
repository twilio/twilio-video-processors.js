{"version":3,"file":"GaussianBlurBackgroundProcessor.js","sourceRoot":"","sources":["../../../lib/processors/background/GaussianBlurBackgroundProcessor.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,6DAAwF;AACxF,6CAAqD;AACrD,qCAAiD;AAgBjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCG;AACH;IAAqD,mDAAmB;IAMtE;;;;OAIG;IACH,yCAAY,OAA+C;QAA3D,YACE,kBAAM,OAAO,CAAC,SAEf;QAZO,uBAAiB,GAAW,8BAAkB,CAAC;QACvD,8CAA8C;QAC7B,WAAK,GAAW,iCAAiC,CAAC;QASjE,KAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAiB,CAAC;;IACpD,CAAC;IAKD,sBAAI,6DAAgB;QAHpB;;WAEG;aACH;YACE,OAAO,IAAI,CAAC,iBAAiB,CAAC;QAChC,CAAC;QAED;;WAEG;aACH,UAAqB,MAAc;YACjC,IAAI,CAAC,MAAM,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,+CAA6C,8BAAkB,iBAAc,CAAC,CAAC;gBAC5F,MAAM,GAAG,8BAAkB,CAAC;aAC7B;YACD,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC;QAClC,CAAC;;;OAXA;IAaS,gEAAsB,GAAhC;QACE,OAAO,0BAAkB,CAAC,IAAI,CAAC;IACjC,CAAC;IAES,wDAAc,GAAxB,UAAyB,UAAkE;QACzF,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACxB,OAAO;SACR;QACD,IAAM,GAAG,GAAG,IAAI,CAAC,cAA0C,CAAC;QAC5D,GAAG,CAAC,MAAM,GAAG,UAAQ,IAAI,CAAC,iBAAiB,QAAK,CAAC;QACjD,GAAG,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAClC,CAAC;IACH,sCAAC;AAAD,CAAC,AA9CD,CAAqD,yCAAmB,GA8CvE;AA9CY,0EAA+B","sourcesContent":["import { BackgroundProcessor, BackgroundProcessorOptions } from './BackgroundProcessor';\nimport { BLUR_FILTER_RADIUS } from '../../constants';\nimport { WebGL2PipelineType } from '../../types';\n\n/**\n * Options passed to [[GaussianBlurBackgroundProcessor]] constructor.\n */\nexport interface GaussianBlurBackgroundProcessorOptions extends BackgroundProcessorOptions {\n  /**\n   * The background blur filter radius to use in pixels.\n   * @default\n   * ```html\n   * 15\n   * ```\n   */\n  blurFilterRadius?: number;\n}\n\n/**\n * The GaussianBlurBackgroundProcessor, when added to a VideoTrack,\n * applies a gaussian blur filter on the background in each video frame\n * and leaves the foreground (person(s)) untouched. Each instance of\n * GaussianBlurBackgroundProcessor should be added to only one VideoTrack\n * at a time to prevent overlapping of image data from multiple VideoTracks.\n *\n * @example\n *\n * ```ts\n * import { createLocalVideoTrack } from 'twilio-video';\n * import { Pipeline, GaussianBlurBackgroundProcessor } from '@twilio/video-processors';\n *\n * const blurBackground = new GaussianBlurBackgroundProcessor({\n *   assetsPath: 'https://my-server-path/assets',\n *   pipeline: Pipeline.WebGL2,\n *   debounce: true,\n * });\n *\n * blurBackground.loadModel().then(() => {\n *   createLocalVideoTrack({\n *     // Increasing the capture resolution decreases the output FPS\n *     // especially on browsers that do not support SIMD\n *     // such as desktop Safari and iOS browsers\n *     width: 640,\n *     height: 480,\n *     frameRate: 24\n *   }).then(track => {\n *     track.addProcessor(blurBackground, {\n *       inputFrameBufferType: 'video',\n *       outputFrameBufferContextType: 'webgl2',\n *     });\n *   });\n * });\n * ```\n */\nexport class GaussianBlurBackgroundProcessor extends BackgroundProcessor {\n\n  private _blurFilterRadius: number = BLUR_FILTER_RADIUS;\n  // tslint:disable-next-line no-unused-variable\n  private readonly _name: string = 'GaussianBlurBackgroundProcessor';\n\n  /**\n   * Construct a GaussianBlurBackgroundProcessor. Default values will be used for\n   * any missing properties in [[GaussianBlurBackgroundProcessorOptions]], and\n   * invalid properties will be ignored.\n   */\n  constructor(options: GaussianBlurBackgroundProcessorOptions) {\n    super(options);\n    this.blurFilterRadius = options.blurFilterRadius!;\n  }\n\n  /**\n   * The current background blur filter radius in pixels.\n   */\n  get blurFilterRadius(): number {\n    return this._blurFilterRadius;\n  }\n\n  /**\n   * Set a new background blur filter radius in pixels.\n   */\n  set blurFilterRadius(radius: number) {\n    if (!radius) {\n      console.warn(`Valid blur filter radius not found. Using ${BLUR_FILTER_RADIUS} as default.`);\n      radius = BLUR_FILTER_RADIUS;\n    }\n    this._blurFilterRadius = radius;\n  }\n\n  protected _getWebGL2PipelineType(): WebGL2PipelineType {\n    return WebGL2PipelineType.Blur;\n  }\n\n  protected _setBackground(inputFrame: OffscreenCanvas | HTMLCanvasElement | HTMLVideoElement): void {\n    if (!this._outputContext) {\n      return;\n    }\n    const ctx = this._outputContext as CanvasRenderingContext2D;\n    ctx.filter = `blur(${this._blurFilterRadius}px)`;\n    ctx.drawImage(inputFrame, 0, 0);\n  }\n}\n"]}